1. laravel using MVC paradigm

2. public/index.php is entry point for our program:
    in index we execute: laravel, composer, bootstrap, kernel, and request

3. kernel in laravel have 2 kernel:
    a. HTTP kernel serve HTTP or web request, first request accepted in
    public/index.php and continue to Kernel class in app/Http folder.
    Bootstrapping in kernel is a Core logic process so that we can receive
    request from Web and handling that request, so we can respond, but this
    just load service provider class in app/providers folder
    b. Console kernel to serve console request.

4. Service provider that do bootstrapping for all component in laravel like:
    database, queue, validation, routing, etc. This process is like
    init.php in our first program in "Project_Tatib" third semester IT
    Polinema. There is a Class in app/Providers that important for basic,
    that is RouteServiceProvides, this class handling routing from our URL
    like what controller and method that we execute for some feature in web

5. this some request cycle: Request->public/index.php->Kernel(if HTTP
    request accepted in HTTP kernel usually for web application, and if
    console request or console application accepted in app/console/Kernel
    .php or console kernel)->Service_Provider(do multiple bootstrapping for
    all component)->if Routing we use RouteServiceProviders
    Class->app/routes folder for more specific routing

6. in laravel there are 2 Testing method:
    a.Unit test: unit testing is test that focus on testing small unit like
    function, method, class, and other component. This test is made to our
    unit code is running in isolation environment without dependency to
    other unit or outside environment. use PHPUnit\Framework\TestCase
    and this test much faster than integration because we
    haven't loaded our laravel. You can use artisan command to make Unit
    Test: "php artisan make:test NameUnitTest --unit".
    b. integration test: test that focus in interaction between unit in some
    big accumulation unit, like interaction view, controller and model
    use Illuminate\Foundation\Testing\TestCase to make integration test.
    This test is much easy to access our laravel component like Database,
    Controller, and other compare to Unit Test also if you use laravel
    feature u must use integration test. To make integration test u can use
    artisan command: "php artisan make:test NameIntegrationTest".
    If you want to run all test
    you can use artisan command: "php artisan test"
    Notes: in function name in our testing class must prefix with test

7. environment setting in laravel much easier with help .env file in our
    project, you can add, edit, and delete manually in there without setting
    environment variable manually in our system.Laravel in function env()
    or you can use Env::get() have default value if our env var hadn't
    existed, here some example:
    env(key, default) => env("THIS_KEY", "DEFAULT")

8. Application environment: sometimes we want to set our application
    running in which environment like: local, development, staging, Qa or
    Production, so in laravel you can change that by edit APP_ENV in .env.
    Note: if you make UnitTest or Integration Test, and want to check your
    application environment, laravel will override your APP_ENV to "testing"
    in file phpunit.xml, this is code: <env name="APP_ENV" value="testing"/>
    If you want to know which app env you code running you can use function
    "App::environment() or App::environment([value1, value2]
    (this for multiple value check)"; so you haven't used function
    env("APP_ENV") to check that

9. Configuration: Environment variable in .env used for configuration that
    always change or frequent to change and integrate in environment
    variable in OS; but laravel also support configuration setting with
    PHP code, this configuration usually used when configuration haven't
    frequently change and this usually same with other app location when
    running, this type configuration is saved in config folder in laravel
    and prefix for this configuration start with name php file within there
    To make config file, you can make file .php in config folder and inside
    that you can return associative array and to receive configuration, you
    can use function => config(key, default)
    with key is "prefix(or nameFile).arrayKey(if nested array you can use .
    like: example.author.first)"
    Note: if you make some file in config folder, try to make file name
    with lowercase

    configuration cache: sometimes we had crated to many config files
    that result in laravel must read all that when we get config, in
    development this seems not big problem, but if our program enter
    production stage, this will make our program became slow, so in laravel
    there is feature for caching our configuration that make our
    configuration became one file, so laravel read process will become much
    faster, because data will be loaded when application is started
    In order to make configuration cache you can type artisan command:
    "php artisan config:cache", but you must do this when production
    deployment process, because when you application's in development stage
    configuration will frequently be changed and once configuration has
    been cached, your application's config that new added will not be used
    and your .env file will not be loaded by the framework during request
    or artisan command and env functions just
    return external system level environment variables and sometimes
    env() function will not work, so for this reason you should called env
    value from config() function by configuration
    file, or you can purged your cached configuration by artisan command
    "php artisan config:clear"

10. Dependencies injection: is some technic that object can receive other
    object or dependency, so those object that receive other object require
    that object to be functional, this make object depend on other object
    which sometimes not good enough, but if your program must require that
    , more recommended if your dependency injection or process insert
    foreign object is from constructor. In laravel we haven't made
    dependency injection manually, because in laravel there is feature that
    can make, maintain, and manage dependency injection in automatically
    way, this feature is Service Container, that represented in Application
    class, but we haven't made instance manually from that class, because
    if you look on public/index.php file, there is $app object that
    defined instance our Application class, so you can use that instance
    to access methods like service container and other services. In
    service container specifically, you haven't made dependency instance
    that use by dependent with 'new' key again, but accessed by
    $classInstance = $app->make(className::class), some notes that if you
    make dependency instance from those way, each class instance you make
    always new and not same object again, also make function in Application
    class cannot process complex class like constructor from dependency
    require parameter, so you can use bind(key, closure) function, in this
    function you can just return array inside closure with value is
    argument that needed for constructor, so when you call make function
    to get dependency instance, automatically bind function is called
    , but same like make function, bind function will called each time make
    function is called, so instance isn't same
    Notes: function like bind(key, closure) and make(key) function isn't
    limited in dependencies instance maker, but you can make all class
    instance that available in you laravel

    A. Singleton method: if before in Application class that instantiate in
     $app variable and have function like bind(key, closure) that return
     instance from our class, but instance always new, so laravel have
     function that return same object even if you called make(key) function
     again and again, this function is singleton(key, closure) function

    B.instance method: if before in Application class that instantiate in
     $app variable and have function like singleton(key, closure) return
     instance from our class, but instance always same, different with that
     instance(key, object) function haven't required closure, but you can
     pass object in parameter. Functionality this function is same like
     singleton(key, closure) function and when you call make(key) function
     again and again, instance that returned is the same object

Notes for bind(key, closure), singleton(key, closure) , and instance(key,
    object) function: if you call make(key) function with key is dependent
    class, laravel with ServiceContainer will automatically search
    dependency class that available and pass the requirements for our
    dependent

    C.Dependency injection in closure: we can use method in Application
    class that specifically in ServiceContainer by use $app instance
    inside closure. This way can be used to pass $app in parameter like
    method bind, instance, and singleton that we used before

    D.Binding interface on class: like I said before, u can use methods
     existing in Application class from
     Illuminate\Foundation\Application or
     in Illuminate\Support\Facade if that method is available like
     bind(interface, class), bind(interface, closure),
     singleton(interface, class), and singleton(interface, closure)
     , with closure function return implemented class(object or instance)
     that extend interface

11. Service container:
    A. Zero Configuration Resolution: if a class has no dependencies or
    only depends on other concrete classes(not interfaces), the container
    doesn't need to be instructed on how to resolve that class like this:
    <?php

        class Service
        {
            // ...
        }
    ?>

    <?php
        Route::get('/', function (Service $service) {
            die($service::class);
        });
    ?>
    this example in routes/web.php file(below). In this example dependency
    injection is resolved by Route::get() function, and many classes will
    be writing when building a laravel application automatically receive
    their dependencies via container, including controllers, event
    listeners, middleware and more.Additionally, you might type-hint the
    dependencies in the handle method of queued jobs that make those task
    faster in response.
    Thanks to zero configuration resolution, you will often type-hint
    dependencies on routes, controllers, event listeners, and elsewhere
    without ever manually interacting with the container. For example, you
    might type-hint the Illuminate\Http\Request object on your route
    definition so that you can easily access the current request. Even
    though we never have to interact with the container to write this
    code, it is managing the injection of these dependencies behind the
    scenes:

        use Illuminate\Http\Request;

        Route::get('/', function (Request $request) {
            // ...
        });

    In many cases, thanks to automatic dependency injection and facades,
    you can build Laravel applications without ever manually binding or
    resolving anything from the container. So, when would you ever
    manually interact with the container? Let's examine two situations.
    First, if you write a class that implements an interface, and you wish
    to type-hint that interface on a route or class constructor, you must
    tell the container how to resolve that interface. Secondly, if you are
    writing a Laravel package that you plan to share with other Laravel
    developers, you may need to bind your package's services into the
    container.

    B.other than Service containers that provide by
     Illuminate\Foundation\Application you can use
     Illuminate\Support\Facades\App
     Facades in Laravel provide a “static” interface to classes that are
     available in the application’s service container. They serve as
     “static proxies” to underlying classes in the service container,
     providing the benefit of a terse, expressive syntax while maintaining
     more testability and flexibility than traditional static methods.
     When you access a facade, Laravel will get the responsible object
     from the service container and pass the data to this object

    C.Service Providers: if service container is a place where your
     service classes are registered, service provider is a central place
     that bootstrapping all laravel applications and manage to register
     all service class to service container and in laravel Service
     Provider are places in App/Providers directory. Each Service provider
     have default method register() and boot() functions. register()
     function is responsible for registering you services(dependencies)
     , notes: you haven't to add code to register() function other than
     registering dependencies or else you will face not found dependencies.
     boot() function is responsible other code that register services.
     You can make Service Provider automatically with artisan command:
     "php artisan make:provider NameServiceProvider"
     When we make Service Provider, in default your service provider hadn't
     load by laravel, so in order to make laravel know about your service
     provider, you can add in config/app.php file, in there had key
     provider that had class-class Service Provider run by laravel, you
     can add in array key "providers" in application services block
     The bindings and singletons Properties
     If your service provider registers many simple bindings, you may wish
     to use the bindings and singletons properties instead of manually
     registering each
     container binding. When the service provider is loaded by the
     framework, it will automatically check for these properties and
     register their bindings

     D. Deferred Service Provider: if your service provider is only
      registering binding in service container, you may choose to
      defer(load provider only when used) until one of the registered
      bindings is actually needed. Deferring the loading of such a provider
      will improve the performance of your application, since it's not
      loaded from the filesystem on every request
      Laravel compiles and stores a list of all it's services supplied by
      deferred service provider, along with the name of it's service
      provider class. Then , only when you attempt to resolve one of
      these services does laravel load the service provider
      To defer the loading of a provider, implement this contract:
      'Illuminate\Contracts\Support\DeferrableProvider' interface and
      define a provides() method. The provides() method should return
      the service container bindings registered by the service provider
      You can change your service provider and make compiled services
      change by:
      1. artisan command: 'php artisan clear-compiled'
      2. do some process stuff like running you application
       : 'php artisan serve' like that

12. Facades: before when interact with features in laravel we use
    dependency injection, but sometimes, there are cases when we haven't
    retrieved application object like when we make class that isn't
    laravel feature(
        before we create class in test/Feature and Providers
        folder which those folder is laravel feature, so we can use $app
        or Application object, but what if we make class that hadn't
        laravel feature?, in order to access that in static way you can
        use facades
    ),
    so facades can be used. Facades provides static access
    through features in service container or Application class and in
    summary laravel facades provide access to almost all of laravel
    features, All of Laravel's facades are defined in the
    Illuminate\Support\Facades namespace. So, we can easily access a
    facade, for example:

    <?php
        use Illuminate\Support\Facades\Cache;
        use Illuminate\Support\Facades\Route;

        Route::get('/cache', function () {
          return Cache::get('key');
        });
    ?>

    But you must use facades just when your needed, like when you can use
    dependencies injection, always use dependencies injection, because use
    to many facades will make your unconsciousness that your class had
    much dependency to use, and you haven't known that and the primary
    danger of facades is class "scope creep". Since facades are so easy to
    use and do not require injection, it can be easy to let your classes
    continue to grow and use many facades in a single class. Using
    dependency injection, this potential is mitigated by the visual
    feedback a large constructor gives you that your class is growing too
    large. So, when using facades, pay special attention to the size of
    your class so that its scope of responsibility stays narrow. If your
    class is getting too large, consider splitting it into multiple
    smaller classes, but if you make dependencies injection manually, you
    can see how many parameters that we had to pass in constructor.

    A. Facades vs. Dependency Injection
     One of the primary benefits of dependency injection is the ability to
     swap implementations of the injected class. This is useful during
     testing since you can inject a mock or stub and assert that various
     methods were called on the stub.
     Typically, it would not be possible to mock or stub a truly static
     class method. However, since facades use dynamic methods to proxy
     method calls to objects resolved from the service container, we
     actually can test facades just as we would test an injected class
     instance. For example, given the following route:

     <?php
       use Illuminate\Support\Facades\Cache;

       Route::get('/cache', function () {
           return Cache::get('key');
       });
     ?>

     Using Laravel's facade testing methods, we can write the following
     test to verify that the Cache::get method was called with the
     argument we expected:

     <?php
       use Illuminate\Support\Facades\Cache;

       /**
        * A basic functional test example.
        */
       public function test_basic_example(): void
       {
           Cache::shouldReceive('get')
                ->with('key')
                ->andReturn('value');

           $response = $this->get('/cache');

           $response->assertSee('value');
       }
     ?>

    B.Facades vs. Helper Functions: in facades there is Helper function
     this different with Helper functions that those functions not
     collected in one class like facades. Before we use Helper functions
     like config() or env(), this provide more easy to use
     helper, but some function compare to facades, helper in facades is
     more simple by code.You can mix helper function and facades, because
     Helper functions are globally and became complement to facades,
     Laravel offers a variety of global "helper functions" that make it
     even easier to interact with common Laravel features. Some of the
     common helper functions you may interact with are view, response,
     url, config, and more.
     Each helper function offered by Laravel is documented with
     their corresponding feature; however, a complete list is available
     within the dedicated helper documentation.
     For example, instead of using the Illuminate\Support\Facades\Response
     facade to generate a JSON response, we may simply use the response
     function. Because helper functions are globally available, you do not
     need to import any classes in order to use them:

     instead using this:
     <?php
          use Illuminate\Support\Facades\Response;

          Route::get('/users', function () {
              return Response::json([
                  // ...
              ]);
          });
     ?>

     you can use helper functions that global:
      <?php
          Route::get('/users', function () {
              return response()->json([
                  // ...
              ]);
          });
      ?>

      For example again, this facade call and helper call are equivalent:

      Facade call:
      return Illuminate\Support\Facades\View::make('profile');

      Helper call:
      return view('profile');

      There is absolutely no practical difference between facades and
      helper functions. When using helper functions, you may still test
      them exactly as you would the corresponding facade. For example,
      given the following route:

      <?php
          Route::get('/cache', function () {
              return cache('key');
          });
      ?>

      The cache helper is going to call the get method on the class
      underlying the Cache facade. So, even though we are using the helper
      function, we can write the following test to verify that the method
      was called with the argument we expected:

      <?php
          use Illuminate\Support\Facades\Cache;

          /**
           * A basic functional test example.
           */
          public function test_basic_example(): void
          {
              Cache::shouldReceive('get')
                   ->with('key')
                   ->andReturn('value');

              $response = $this->get('/cache');

              $response->assertSee('value');
          }
      ?>

      C. How facade works: in laravel applications, facades is a class that
       provides access to objects dependency from the service container.
       This machinery that makes this work is in the Facade class, also
       many helper functions that called by facade or called in static way
       also extend Facade class, so laravel facades and any custom facades
       you create, will extend base 'Illuminate\Support\Facades\Facade'
       In Facade class have a method __callStatic() that uses like magic
       method or meta programming that will call method in dependency in
       Service Container, although we call static method we pass in
       static way like 'Route::get()', this will call get method in Route
       dependency in service container
       By glancing at this code, one might assume that the static get method is being called on the Cache class:

       <?php

           namespace App\Http\Controllers;

           use App\Http\Controllers\Controller;
           use Illuminate\Support\Facades\Cache;
           use Illuminate\View\View;

           class UserController extends Controller
           {
               /**
                * Show the profile for the given user.
                */
               public function showProfile(string $id): View
               {
                   $user = Cache::get('user:'.$id);

                   return view('profile', ['user' => $user]);
               }
           }
       ?>

       Notice that near the top of the file we are "importing" the Cache
       facade. This facade serves as a proxy for accessing the underlying
       implementation of the Illuminate\Contracts\Cache\Factory interface.
       Any calls we make using the facade will be passed to the underlying
       instance of Laravel's cache service.

       If we look at that Illuminate\Support\Facades\Cache class, you'll
       see that there is no static method get:

       <?php
           class Cache extends Facade
           {
               /**
                * Get the registered name of the component.
                */
               protected static function getFacadeAccessor(): string
               {
                   return 'cache';
               }
           }
       ?>

       Instead, the Cache facade extends the base Facade class and defines
       the method getFacadeAccessor(). This method's job is to return the
       name of a service container binding. When a user references any
       static method on the Cache facade, Laravel resolves the cache
       binding from the service container and runs the requested method
       (in this case, get) against that object.

       D. Make Custom Facades: in order to make custom facades:
        1. you can create your original class in app folder(
            you can create that inside folder
        )
        2. make class for accessing those original class, this class
         must extend Facade class from 'Illuminate\Support\Facades\Facade'
         and add method getFacadeAccessor() and return camelCase your
         original class name
        3. make Service Providers that in register() method you have to
         registered with bind(), singleton() method with abstract
         parameter is class name that return in getFacadeAccessor()
         method and concrete parameter is instance from original class.
         If you have to make Your Service Provider for facades became
         deferred, you can implement DeferrableProvider contract
        4. register your Service Provider with add in app.config file part
         'providers' array key with value your service provider like:
         'App\Providers\CustomProvider::class'
        5. adding static methods finder in class that accessing original
         class that extend Facade class like:
         /**
          * @method static string hey()
          * @method static array bro()
          *
          * @see \App\TestFacades\OriginalClass
          */
          you can see, string is return type your function, and hey() is
          name your function that in original class
         6.you can create aliases in app.config file part 'aliases' array
          key with value like: 'nameAlias =>
          App\PathToAccessorFacade::class', but this I can't understand
          how it works; that works, but PHP Storm can't detect our
          aliases, this new problem
         7. last don't forget to refresh your compiled class by artisan
          command: 'php artisan clear-compiled' and do some stuff like
          'php artisan serve' to re-register you boostrap cache

        E. Facades Mock: some lack with static functions is difficult to
         do testing, but laravel provides functions that do mocking test
         in facades, so we can easily implement feature testing or unit
         testing, because laravel use Mockery Library for Mocking in
         Facades

13. Routing: you can check existing routes by: 'php artisan route:list'
    A. Basic Routing: The most basic routes accept a URL and a closure,
     providing a very simple and expressive method of defining routes and
     behavior without complicated routing configuration files, example:

     <?php
        use Illuminate\Support\Facades\Route;

        Route::get('/greeting', function () {
            return 'Hello World';
        });
     >?


   B. Static method Route: you can adapt specific HTTP Verb like this:
    Route::get($url, $callback)     : For retrieving data + param
    Route::post($url, $callback)    : For sending data
    Route::put($url, $callback)     : For updating entirely data + param
    Route::patch($url, $callback)   : For updating specific data + param
    Route::delete($url, $callback)  : For removing specific data + param
    Route::options($url, $callback) : For retrieving the allowed methods
    Route::any($url, $callback)     : For allows any HTTP verbs
    Route::match(['put', 'other verb'], $url, $callback)   : For allows defined HTTP verbs

   C. Testing Routes: you can test routes is successfully or not like this:
    this just test basic routes with string as return value
    <?php
        class NameTest extends TestCase
        {
            public function testName()
            {
                $this->get('/nameUrl')
                    ->assertStatus(200)
                    ->assertContent('you return text');
            }
        }
    ?>

   D. Redirecting Routes: you can redirect from one url to another url
    with 'Route::redirect($fromUrl, $toUrl)';
    and to test your redirect routes is successfully or not you can do:
    $this->get('/fromUrl')
        ->assertRedirect('/toUrl')
    ;

   E. Not found Route: if you try to access route that doesn't exist,
   laravel will automatically send page to 404 not found page, but you can
   change the page 404 to custom page for this, you can do function:
   'Route::fallback($closure)'

   E. Route Parameters:
    A.Required Parameters: sometimes you will need to capture segments of
    the url within your route.For example, you may need to capture a
    user's ID from the URL. You may do so by defining route parameters:

        Route::get('/user/{id}', function (string $id) {
          return 'User '.$id;
        });

        You may define as many route parameters as required by your route:

        Route::get('/posts/{post}/comments/{comment}', function (string
        $postId, string $commentId) {
          // ...
        });
    like above example, laravel supports route parameters, so we can
    automatically retrieve data in closure function or in array, but in
    order to retrieve data parameters, Route Parameters are always encased
    within {} braces and should consist of alphabetic characters, also
    underscore(_) are acceptable within route parameter names. Route
    parameters are injected into route callbacks / controllers based on
    their order-the names of the route callback / controller arguments
    do not matter

    B. Optional Parameters
    Occasionally you may need to specify a route parameter that may not
    always be present in the URI. You may do so by placing a ? mark after
    the parameter name. Make sure to give the route's corresponding
    variable a default value:

        Route::get('/user/{name?}', function (?string $name = null) {
            return $name;
        });

        Route::get('/user/{name?}', function (?string $name = 'John') {
            return $name;
        });

    C.Regular Expression Constraint:
    You may constrain the format of your route parameters using the where
    method on a route instance. The where() method accepts the name of the
    parameter and a regular expression defining how the parameter should
    be constrained:

        Route::get('/user/{name}', function (string $name) {
            // ...
        })->where('name', '[A-Za-z]+');

        Route::get('/user/{id}', function (string $id) {
            // ...
        })->where('id', '[0-9]+');

        Route::get('/user/{id}/{name}', function (string $id, string $name) {
            // ...
        })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

    For convenience, some commonly used regular expression patterns have
    helper methods that allow you to quickly add pattern constraints to
    your routes:
        //this for regex manual: '[0-9]+'
        Route::get('/user/{id}/{name}', function (string $id, string $name) {
            // ...
        })->whereNumber('id')->whereAlpha('name');

        //this for regex manual: '[a-zA-Z]+'
        Route::get('/user/{name}', function (string $name) {
            // ...
        })->whereAlpha('name');

        //this for regex manual: '[a-zA-Z0-9]+'
        Route::get('/user/{name}', function (string $name) {
            // ...
        })->whereAlphaNumeric('name');

        Route::get('/user/{id}', function (string $id) {
            // ...
        })->whereUuid('id');

        Route::get('/user/{id}', function (string $id) {
            //
        })->whereUlid('id');

        //this for regex that matches values in an array
        Route::get('/category/{category}', function (string $category) {
            // ...
        })->whereIn('category', ['movie', 'song', 'painting']);

    If the incoming request does not match the route pattern constraints,
    a 404 HTTP response will be returned, or you can custom by create
    fallback function for your route.

    D.Globals Constraint: If you would like a route parameter to always
     be constrained by a given regular expression, you may use the pattern
     method. You should define these patterns in the boot method of your
     App\Providers\RouteServiceProvider class:

        /**
        * Define your route model bindings, pattern filters, etc.
        */
        public function boot(): void
        {
          Route::pattern('id', '[0-9]+');
        }

        Once the pattern has been defined, it is automatically applied to
        all routes using that parameter name:

        Route::get('/user/{id}', function (string $id) {
          // Only executed if {id} is numeric...
        });

    E.Encoded Forward Slashes
    The Laravel routing component allows all characters except / to be
    present within route parameter values. You must explicitly allow /
    to be part of your placeholder using a where condition regular
    expression:

    Route::get('/search/{search}', function (string $search) {
      return $search;
    })->where('search', '.*');

    Warning:
    Encoded forward slashes are only supported within the last route
    segment.

    F. Routing Conflict: in laravel if your route is conflict with another
    route, this will haven't caused error, but laravel will prioritize
    route that first that make or route that above compare to conflicted
    routes

    G.Named Route: in laravel we can be naming route allow convenient
    generation of URLs of redirects for specific routes. You may specify
    a name for a route by chaining the name() method onto the route
    definition:
        Route::get('/user/profile', function () {
            // ...
        })->name('profile');

        You may also specify route names for controller actions:

        Route::get(
            '/user/profile',
            [UserProfileController::class, 'show']
        )->name('profile');

    Warning:
    Route names should always be unique.

    Generating URLs to Named Routes
    Once you have assigned a name to a given route, you may use the
    route's name when generating URLs or redirects via Laravel's route
    and redirect helper functions:

        // Generating URLs...
        $url = route('profile');

        // Generating Redirects...
        return redirect()->route('profile');

        return to_route('profile');

    If the named route defines parameters, you may pass the parameters as
    the second argument to the route function. The given parameters will
    automatically be inserted into the generated URL in their correct
    positions:

        Route::get('/user/{id}/profile', function (string $id) {
            // ...
        })->name('profile');

        $url = route('profile', ['id' => 1]);

    If you pass additional parameters in the array, those key / value
    pairs will automatically be added to the generated URL's query string:

        Route::get('/user/{id}/profile', function (string $id) {
            // ...
        })->name('profile');

        $url = route('profile', ['id' => 1, 'photos' => 'yes']);

        // /user/1/profile?photos=yes

    Sometimes, you may wish to specify request-wide default values for
    URL parameters, such as the current locale. To accomplish this, you
    may use the URL::defaults method.

14. Controller: instead of defining all of your request handling logic as
    closure in route web.php files, you may wish to organize this
    behavior using 'controller' classes. Controller can group related
    request handling logic into a single class. For example a
    UserController class might handle all incoming request related to
    user model.By default, controllers are stored in the
    app/Http/Controllers directory.

    A.Basic Controllers
      To quickly generate a new controller, you may run the
      make:controller Artisan command. By default, all the controllers
      for your application are stored in the app/Http/Controllers
      directory:

      "php artisan make:controller UserController"

      Let's take a look at an example of a basic controller. A controller
      may have any number of public methods which will respond to
      incoming HTTP requests:

          <?php

          namespace App\Http\Controllers;

          use App\Models\User;
          use Illuminate\View\View;

          class UserController extends Controller
          {
              /**
               * Show the profile for a given user.
               */
              public function show(string $id): View
              {
                  return view('user.profile', [
                      'user' => User::findOrFail($id)
                  ]);
              }
          }

      Once you have written a controller class and method, you may define
      a route to the controller method like so:

          use App\Http\Controllers\UserController;

          Route::get('/user/{id}', [UserController::class, 'show']);

      When an incoming request matches the specified route URI, the show
      method on the App\Http\Controllers\UserController class will be
      invoked and the route parameters will be passed to the method.

      Notes:
      Controllers are not required to extend a base class. However, you
      will not have access to convenient features such as the middleware
      and authorize methods.

   B. Single Action controllers: If a controller action is particularly
      complex, you might find it convenient to dedicate an entire
      controller class to that single action. To accomplish this, you may
      define a single __invoke method within the controller:

         <?php

         namespace App\Http\Controllers;

         class ProvisionServer extends Controller
         {
             /**
              * Provision a new web server.
              */
             public function __invoke()
             {
                 // ...
             }
         }
     When registering routes for single action controllers, you do not
     need to specify a controller method. Instead, you may simply pass
     the name of the controller to the router:

         use App\Http\Controllers\ProvisionServer;

         Route::post('/server', ProvisionServer::class);
     You may generate an invokable controller by using the --invokable
     option of the make:controller Artisan command:

     "php artisan make:controller ProvisionServer --invokable"

     Notes:
     Controller stubs may be customized using stub publishing.

   C. Dependency Injection in Controller: In service container is used to
    resolve all laravel controllers  As a result, you are able to
    type-hint any dependencies your controller may need in its
    constructor. The declared dependencies will automatically be resolved
    and injected into the controller instance, but before you must
    register your service provider in service container.
    here code in App/Http/Controller/:

        <?php

        namespace App\Http\Controllers;

        use App\Repositories\UserRepository;

        class UserController extends Controller
        {
            /**
             * Create a new controller instance.
             */
            public function __construct(
                protected UserRepository $users,
            ) {
            }

            public function index() {
                return $this->$users->test();
            }
        }

    Here code in routes web.php:
        Route::get('/userController', [UserController::class, 'index']);


15. View: in order to create response in HTML and more complex appearance,
    you can add view in resources/views folder. This to separate the logic
    of application and code for appearance, so View feature came in
    laravel to provide a convenient way to place all of our HTML in
    separate files. When using laravel view templates are usually written
    using the Blade templating language , a simple view might look like
    this:notes: blade template have format: 'nameFile.blade.php'
    <?php
        <!-- View stored in resources/views/greeting.blade.php -->

        <html>
            <body>
                <h1>Hello, {{ $name }}</h1>
            </body>
        </html>
    ?>
    Since this view is stored at resources/views/greeting.blade.php, we
    may return it using the global view helper like so:
    <?php
        Route::get('/', function () {
            return view('greeting', ['name' => 'James']);
        });
    ?>

    Some benefit using blade template engine, separated logical code with
    view or appearance, in simple ways we avoid php syntax in view,
    although we can  write php syntax in there, but that isn't recommended.
    Like example code above, using blade template engine, will create real
    code php in storage/framework/view folder with name of view .php is
    hashed.

    A. Nested View directory: View may also be nested within
    subdirectories of the resources/views directory. "Dot" notation may be
    used to reference nested views. For example, if your view is stored
    at resources/views/admin/profile.blade.php, you may return it from
    one of your application's routes or controllers like so:

    return view('admin.profile', $arrData);

    B. Testing View: if you want to test you view like that echo like our
     want or not you can get() method with assertSeeText() method, but
     remember, if we pass string in the assertSeeText() method that
     prefixes is same, example:
     actual text: 'Anas heh'
     assertSeeText param: 'A'
     this will also return true when testing is running
     You can test more accurate your view using view() method like this:
     public function testViewWithoutRoute()
     {
         $this->view('nestedFolder.viewWithoutRoute', ['name' => 'Anas'])
             ->assertSeeText('Hallo: Anas');
     }
     this test format, will return false if your param in assertSeeText()
     is not correct with actual value


16. Static assets bundling: In laravel 10 and 11, bundling assets is
    processed by Vite bundle in Node, when referencing asset in your JS or
    CSS, Vite automatically processes and versions them, also Vite
    processes static assets that you reference solely in Blade templates

    A.Configuring Vite:
    Vite is configured via a vite.config.js file in the root of your
    project. You are free to customize this file based on your needs, and
    you may also install any other plugins your application requires, such
    as @vitejs/plugin-vue or @vitejs/plugin-react.
    The Laravel Vite plugin requires you to specify the entry points for
    your application. These may be JavaScript or CSS files, and include
    preprocessed languages such as TypeScript, JSX, TSX, and Sass.
    This default Vite configuration:

        import { defineConfig } from 'vite';
        import laravel from 'laravel-vite-plugin';

        export default defineConfig({
            plugins: [
                laravel([
                    'resources/css/app.css',
                    'resources/js/app.js',
                ]),
            ],
        });
    If you are building an SPA, including applications built using
    Inertia, Vite works best without CSS entry points:

        import { defineConfig } from 'vite';
        import laravel from 'laravel-vite-plugin';

        export default defineConfig({
            plugins: [
                laravel([
                    'resources/css/app.css',
                    'resources/js/app.js',
                ]),
            ],
        });
    Instead, you should import your CSS via JavaScript. Typically, this
    would be done in your application's resources/js/app.js file:

        import './bootstrap';
        import '../css/app.css';

    B. Loading your script and styles with Vite to blade:
    With your Vite entry points configured, you may now reference them in
    a @vite() Blade directive that you add to the <head> of your
    application's root template:

        <!doctype html>
        <head>
            {{-- ... --}}

            @vite(['resources/css/app.css', 'resources/js/app.js'])
        </head>
    you can type: 'npm run build' to make your assets building in public
    folder
    For other explanation about Vite bundling packages js, css, sass,
    tailwind, etc. we hadn't explained in basic

17. Http Request: Request in native php is like global variables $_GET,
    $_POST, etc. that relate to request from web. In laravel Request
    processed in Illuminate\Http\Request class, this class provides an
    object-oriented way to interact with the current HTTP request being
    handled by your application as well as retrieve input, cookies, and
    files that were submitted with request

    A. Interact with the Request: To obtain an instance of the current Http request in your url via dependency injection, you should type-hint the Illuminate\Http\Request class on your route closure or
     controller method, and like controller service container will handle
     automatic injection
     Here Request via Controller but not in Routes
     (so in Routes haven't required made Request instance):
        <?php

        namespace App\Http\Controllers;

        use Illuminate\Http\RedirectResponse;
        use Illuminate\Http\Request;

        class UserController extends Controller
        {
            /**
             * Store a new user.
             */
            public function store(Request $request): RedirectResponse
            {
                $name = $request->input('name');

                // Store the user...

                return redirect('/users');
            }
        }

     And here Request just in Routes Closure:
        use Illuminate\Http\Request;

        Route::get('/', function (Request $request) {
            // ...
        });

     B. Request Method: instance($request) request From Request $request
        can be used to retrieve current path, like:
        1. $request->path(): If Url like: Http://example.com/foo/bar will
            return foo/bar
        2. $request->url(): return all Url without query parameter
        3. $request->fullUrl(): return All Url with query parameter
        4. $request->method(): to retrieve current Http verb
        5. $request->isMethod('Http verb'): return true or false compare
            http verb in param
        6. $request->host(): return host like 'localhost'
        7. $request->httpHost(): return host with port like 'localhost:81'
        7. $request->schemeHttpHost(): return full host with port like
           'http://localhost:81'
        notes: for request method that for receive host, will return only
          corresponding host not with other added in url like controller,
          method, also params

     C. Request input: for retrieve input form user, whatever the source
        is form, or query parameter, in Request class there is method
        that can be used specific depending on situations, here method:
        1.$request->all(): retrieve all of the incoming request's input
        data as an array, whatever the incoming request is from and HTML
        form or is an XHR request( or XMLHttpRequest:
            objects are used to interact with servers. You can retrieve
            data from a URL without having to do a full page refresh
        )
        2.$request->collect(): retrieved input will be part of Collection
        .Like other collection, there are many of methods to process your
         collection like avg(), median(), concat(), macro(), etc.
        3.$request->input(key, default): To access all the user input
        from your Illuminate\Http\Request => Request class instance
        without worrying about which Http verb was used for the
        request.Regardless of the HTTP verb, the input() may be used
        like:
            a. retrieved input variable: input('nameVar')
            b. retrieved input variable with default value if isn't exist
               that variable: input('nameVar', 'default value')
            c. retrieved input with array associative: input('key1.key2')
               or you can like this: input('key1.*.key3'), this will take
               all key subset from array key 'key1'
            d.retrieved all the input values with as an array associative
                : input()
            e.retrieved only query parameters: query(key, default)

        4.Input type: in laravel there are ways to convert retrieved input
        in automatic way such as:
            a. $request->string('nameVar'): instead retrieving input as
                a primitive string, make input as an instance of
                Illuminate\Support\Stringable. As an instance, you can use
                method in that class. You may notice that native php has
                method like lcfirst() too, but there is advantage such
                chaining methods like:
                $request->string(key, default)->lcfirst()->snake();
                This code provides more flexibility in chaining methods
                that in native php like:
                lcfirst(snake('you string value'));
